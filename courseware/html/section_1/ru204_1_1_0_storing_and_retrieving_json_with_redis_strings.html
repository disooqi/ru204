<style type= text/css>
    .code {font-family: 'courier new', courier; font-weight: bold; font-size: 18px !important; }
</style>
<p>The traditional approach to storing JSON documents in Redis has been to serialize them to Strings.  Serialization happens in application code, with the resulting String value saved in Redis using the <code>SET</code> command.</p>
<p>Reading or updating JSON documents stored in this way can be a costly operation. The entire document needs to be retrieved from Redis, and deserialized back to its original form, a process that usually happens in your application's code.</p>
<img src="//university.redis.com/asset-v1:redislabs+RU204+2022_01+type@asset+block@JSON_to_String.png" alt="Mapping JSON to Redis String">
<p>Serialized JSON Documents cannot be updated by Redis String commands. The process of retrieving, deserializing, updating, re-serializing, then re-storing the document to update a single field would be considered an expensive set of operations for both Redis and the client application.</p>
<img src="//university.redis.com/asset-v1:redislabs+RU204+2022_01+type@asset+block@JSON_to_Hash.png" alt="Mapping JSON to Redis Hash">
<p>A more efficient solution than a String could be the Hash data type. Hashes store multiple field-value pairs at a single key.  Accessing Hash values is a constant-time complexity operation, so this is a valid solution. When serializing JSON to a Redis Hash, we can only go one level deep, so arrays and embedded objects in the JSON document still need to be serialized to String values or modeled in a different way.</p>
<img src="//university.redis.com/asset-v1:redislabs+RU204+2022_01+type@asset+block@JSON_to_multi.png" alt="Mapping JSON to multiple Redis keys">
<p>Using more of the native data types in Redis, Lists and Hashes could be created for a JSON document's nested objects. This would require a document to be broken up and stored in multiple different Redis keys.  Creating, reading, updating and deleting a document would require multiple calls to Redis as well as incurring the overhead required to marshall data between Redis data types and JSON.  This approach can quickly become unwieldy and should be considered  an anti-pattern, as the goal of Redis is for speed and efficiency.</p>
  